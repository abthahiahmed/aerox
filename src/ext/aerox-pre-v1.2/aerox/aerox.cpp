#include "aerox.hpp"



Aerox::Aerox(){
	
	
	this->developmentMode = false;
	this->tailwindcssEnabled = true;
	
	pagesDir = "./pages";
	componentsDir = "./components";
	targetBuildPath = "./.aerox";
}

void Aerox::disableTailwindcss(){
	this->tailwindcssEnabled = false;
}

void Aerox::enableDevelopment(){
	this->developmentMode = true;
}

string Aerox::getFileContent(string path){
	ifstream file(path);
	
	if (!file.is_open()) return "";
	
	string content = "";
	string line;
	while (getline(file, line)){
		content += line + "\n";
	}
	
	file.close();
	return content;
}




void Aerox::generateParsedCode(string filename, string content){
	
	ofstream file(filename);
	
	string header = "#include \"../../src/include/pages.hpp\"\n"
					"#include \"../../src/include/components.hpp\"\n" 
					"#include \"../../src/include/metadata.hpp\"\n\n"+ content;
	
	if (!file.is_open()) return;
	
	file << header << endl;
	
	file.close();
	
}

void Aerox::generateParsedComponent(string filename, string content){
	
	ofstream file(filename);
	
	string header = "#include \"../../src/include/components.hpp\"\n\n" 
					"#include \"../../src/include/document.hpp\"\n\n" + content;
	
	
	if (!file.is_open()) return;
	
	file << header << endl;
	
	file.close();
	
}

void Aerox::generatePages(){
	string pagesInclude = "#pragma once\n"
		"#ifndef PAGES_HPP\n"
		"#define PAGES_HPP\n"
		"#include <iostream>\n"
		"#include <unordered_map>\n"
		"#include <functional>\n"
//		"#include \"metadata.hpp\"\n"
		"#include \"response.hpp\"\n"
		"#include \"request.hpp\"\n"
		"using namespace std;\n\n";
	
	for (auto f : renderFunctions){
		pagesInclude += f + "\n";
	}
	
	pagesInclude += "#endif\n";
	
	ofstream pages("./src/include/pages.hpp");
	if (pages.is_open()){
		pages << pagesInclude <<endl;
	}
	pages.close();
}

void Aerox::generateMetadata(){
	string md = "#ifndef METADATA_HPP\n"
				"#define METADATA_HPP\n"
				"#include <iostream>\n"
				"using namespace std;\n"
				"extern string __title__;\n"
				"extern string __description__;\n"
				"#endif\n";
	
	ofstream metadata("./src/include/metadata.hpp");
	if (metadata.is_open()){
		metadata << md <<endl;
	}
	metadata.close();
}

void Aerox::generateComponents(){
	string compInclude = "// This file is generated by Aerox dynamically while building\n"
		"#pragma once\n"
		"#ifndef COMPONENTS_HPP\n"
		"#define COMPONENTS_HPP\n"
		"#include <iostream>\n"
		"#include \"metadata.hpp\"\n"
		"using namespace std;\n\n";
	
	for (auto f : componentFunctions){
		compInclude += f + "\n";
	}
	
	compInclude += "#endif\n";
	
	ofstream components("./src/include/components.hpp");
	if (components.is_open()){
		components << compInclude <<endl;
	}
	components.close();
}

void Aerox::generateRenders(){
	
	
	string renders = "// This file is generated by Aerox dynamically while building\n"
	"#include \"pages.hpp\"\n"
	"#include \"components.hpp\"\n"
	"#include \"../ext/json.hpp\"\n"
	"static unordered_map<string, function<void(Request, Response)>> pages;\n"
	"static string sendNavigationResponse(string page){\n"
	"\tnlohmann::json data;\n"
	"\tdata[\"body\"] = page;\n"
	"\tnlohmann::json meta;\n"
	"\tmeta[\"title\"] = __title__;\n"
	"\tmeta[\"description\"] = __description__;\n"
	"\tdata[\"meta\"] = meta;\n"
	"\treturn data.dump();\n"
	"}\n"
	"static void initRenders(){\n";
	
	for (int i = 0; i < renderFunctions.size(); i++){
		renders += "\tpages[\"" + renderRoutes[i] + "\"] = [](Request req, Response res){\n"
					"\t\tstring page = " + renderFunctionCalls[i] + "(req);\n"
					"\t\tstring root = MainRoot(page);\n"
					"\t\tif (req.query[\"navigate\"] != \"\")\n"
					"\t\t\tres.sendJSON(sendNavigationResponse(page));\n"
					"\t\telse\n"
					"\t\t\tres.send(root);\n"
					"\t__title__ = \"\";\n"
					"\t__description__ = \"\";\n"
					"\t};\n\n";
	}
	
	renders += "}\n";
	
	ofstream render("./src/include/render.hpp");
	if (render.is_open()){
		render << renders <<endl;
	}
	render.close();
}

bool Aerox::replace(std::string& str, const std::string& from, const std::string& to) {
    size_t start_pos = str.find(from);
    if(start_pos == std::string::npos)
        return false;
    str.replace(start_pos, from.length(), to);
    return true;
}

string Aerox::toRoute(string filename){
	
	replace(filename, "./pages", "");
	
	if (filename.length() > 4){
		filename.resize(filename.length() - 4);
	}
	
//	cout<<filename<<endl;
	return filename;
}

void Aerox::singleParseAndBuild(string file){
	
	int id = 0;
	
	// Parse and build all the pages...
	for (auto& entry : filesystem::recursive_directory_iterator(pagesDir)){
		if (filesystem::is_regular_file(entry.path())){
			id++; // File id
			
			
			string filename = entry.path().filename().string(); // Get filename
			string filePath = entry.path().string(); // Get path/to/file
			
			if (filePath == file){
				string outputFile = targetBuildPath + "/pages" + "/_" + to_string(id) + "_" + filename;
				
				
				string code = getFileContent(entry.path());
				string parsedCode = parseContent(filePath, code, false);
				
				generateParsedCode(outputFile, parsedCode);
				
//				allFiles.emplace_back(filePath);
//				allParsedFiles.emplace_back(outputFile);
//				
				if (filename == "index.cpp"){
					replace(filePath, "index.cpp", "");
				}
				
//				renderRoutes.emplace_back(toRoute(filePath));
				
				if (errors.size() < 1) cout<<"[√] Translated page : " << entry.path().string() << " -> " << toRoute(filePath)<<endl;
				break;
			}
			
 		}
	}
	

	// Parse and build all components...
	for (auto& entry : filesystem::recursive_directory_iterator(componentsDir)){
		if (filesystem::is_regular_file(entry.path())){
			id++; // File id
			
			string filename = entry.path().filename().string(); // Get filename
			
			string filePath = entry.path().string(); // Get path/to/file
			
			if (filePath == file){
				string outputFile = targetBuildPath + "/components" + "/_" + to_string(id) + "_" + filename;
				
				
				string code = getFileContent(entry.path());
				string parsedCode = parseContent(filePath, code, true);
				
				generateParsedComponent(outputFile, parsedCode);
				
				if (errors.size() < 1) cout<<"[√] Translated component : " << entry.path().string() <<endl;
				
//				allFiles.emplace_back(filePath);
//				allParsedFiles.emplace_back(outputFile);
				break;
			}
 		}
	}
	
	if (errors.size() > 0){
		for (auto error : errors){
			cout<<error<<endl;
		}
		cout<<"Building terminated unsuccesfully..."<<endl;
		exit(1);
	}else{
		cout<<"Pages & components translated successfuly..."<<endl;
	}

//	generateRenders();
//	generatePages();
//	generateComponents();
//	generateMetadata();
//
//	renderFunctions.clear();
//	renderFunctionCalls.clear();
//	renderRoutes.clear();
//	componentFunctions.clear();
//	metaData.clear();
	
}

void Aerox::parseAndBuild(){
	
	int id = 0;
	
	// Parse and build all the pages...
	for (auto& entry : filesystem::recursive_directory_iterator(pagesDir)){
		if (filesystem::is_regular_file(entry.path())){
			id++; // File id
			
			
			string filename = entry.path().filename().string(); // Get filename
			string filePath = entry.path().string(); // Get path/to/file
			
			string outputFile = targetBuildPath + "/pages" + "/_" + to_string(id) + "_" + filename;
			
			
			string code = getFileContent(entry.path());
			string parsedCode = parseContent(filePath, code, false);
			
			generateParsedCode(outputFile, parsedCode);
			
			allFiles.emplace_back(filePath);
			allParsedFiles.emplace_back(outputFile);
			
			if (filename == "index.cpp"){
				replace(filePath, "index.cpp", "");
			}
			
			renderRoutes.emplace_back(toRoute(filePath));
			
			if (errors.size() < 1) cout<<"[√] Translated page : " << entry.path().string() << " -> " << toRoute(filePath)<<endl;
			
			
 		}
	}
	

	// Parse and build all components...
	for (auto& entry : filesystem::recursive_directory_iterator(componentsDir)){
		if (filesystem::is_regular_file(entry.path())){
			id++; // File id
			
			string filename = entry.path().filename().string(); // Get filename
			string filePath = entry.path().string(); // Get path/to/file
			string outputFile = targetBuildPath + "/components" + "/_" + to_string(id) + "_" + filename;
			
			string code = getFileContent(entry.path());
			string parsedCode = parseContent(filePath, code, true);
			
			generateParsedComponent(outputFile, parsedCode);
			
			if (errors.size() < 1) cout<<"[√] Translated component : " << entry.path().string() <<endl;
			
			allFiles.emplace_back(filePath);
			allParsedFiles.emplace_back(outputFile);
 		}
	}
	
	if (errors.size() > 0){
		for (auto error : errors){
			cout<<error<<endl;
		}
		cout<<"Building terminated unsuccesfully..."<<endl;
		exit(1);
	}else{
		cout<<"Pages & components translated successfuly..."<<endl;
	}

	generateRenders();
	generatePages();
	generateComponents();
	generateMetadata();

//	renderFunctions.clear();
//	renderFunctionCalls.clear();
//	renderRoutes.clear();
//	componentFunctions.clear();
//	metaData.clear();
	
}

void Aerox::run(){

	
	this->parseAndBuild();


	vector<string> errors;
	
//	string objectFiles = "";
//	for (auto file: allParsedFiles){
//		string objectFile = file + ".o ";
//		string cmd = "g++ -c " + file + " -o " + objectFile;
//		system(cmd.c_str());
//		objectFiles += objectFile;
//	}
	
	string compiler = "g++ main.cpp ./src/*/*.cpp ./.aerox/*/*.cpp -lSDL2main -lSDL2 -lSDL2_net -o main";
	cout<<"Compiling..."<<endl;
	system(compiler.c_str());
	
	this->isServerRunning = true;
	cout<<"Server is starting..."<<endl;
	
	thread serverThread(this->runServer);
	
	
	function<void(int)> cb = [this](int index){
		
		parseAndBuild();
		
//		string objectFile = this->allParsedFiles[index] + ".o ";
//		string cmd = "g++ -c " + this->allParsedFiles[index] + " -o " + objectFile;
//		system(cmd.c_str());
		
		string compiler = "g++ main.cpp ./src/*/*.cpp  ./.aerox/*/*.cpp -lSDL2main -lSDL2 -lSDL2_net -o main";
		cout<<"Compiling..."<<endl;
		system(compiler.c_str());
	};
	
	
	if (this->developmentMode && this->tailwindcssEnabled){
		
		thread fileChangesDetectThread(this->detectFilechanges, this->allFiles, cb);
		thread tailwindcssThread(this->tailwindcss);
		
		fileChangesDetectThread.join();
		tailwindcssThread.join();
	}
	else if (!this->developmentMode && this->tailwindcssEnabled){
		thread tailwindcssThread(this->tailwindcss);
		tailwindcssThread.join();
	}
	else if (this->developmentMode && !this->tailwindcssEnabled){
		thread fileChangesDetectThread(this->detectFilechanges, this->allFiles, cb);
		fileChangesDetectThread.join();
	}
	serverThread.join();
	
}